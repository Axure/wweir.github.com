<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="chrome=1">
		<title></title>
		<style text="text/css">
body {
    overflow-x: hidden;
}
.container {
		margin: 0 auto;
		width: 1020px;
}
.nav-wrap {
    display: block;
    height: 650px;
    float: left;
    position: fixed;
		padding: 3px;
		margin: 0;
		border: 0;
		font: 13px Helvetica, arial, freesans, clean, sans-serif;
		line-height: 1.4;
    
}
.nav {
		display: block;
		float: left;
		position: fixed;
		padding: 3px;
		border-radius: 2px;
		margin: 40px 0 0 0;
		border: 0;
		font: 13px Helvetica, arial, freesans, clean, sans-serif;
		line-height: 1.4;
    background: #ffffff; overflow: hidden;
}
.nav ul {
		background: #fafafb;
		border-radius: 2px;
		border: 1px solid #d8d8d8;
		margin: 0;
		padding: 0;
		list-style: none;
		display: block;
}
.nav ul li {
		display: list-item;
		border-top: 1px solid #fff;
		border-bottom: 1px solid #eee;
}
.nav ul li a {
		display: block;
		padding: 8px 10px 8px 8px;
		text-shadow: 0 1px 0 #fff;
		border-left: 2px solid #fafafb;
		color: #4183c4;
		text-decoration: none;
}
.nav ul li a:-webkit-any-link {
		cursor: auto;
}
.markdown-body {
		font: 13px Helvetica, arial, freesans, clean, sans-serif;
		display: block;
		width: 800px;
    margin: 0 auto;
    font-size: 14px;
    line-height: 1.6;
}
.markdown-body > *:first-child {
    margin-top: 0 !important;
}
.markdown-body > *:last-child {
    margin-bottom: 0 !important;
}
.markdown-body a {
    text-decoration: none;
}
.markdown-body a:hover {
    text-decoration: underline;
}
.markdown-body a.absent {
    color: #CC0000;
}
.markdown-body a.anchor {
    bottom: 0;
    cursor: pointer;
    display: block;
    left: 0;
    margin-left: -30px;
    padding-left: 30px;
    position: absolute;
    top: 0;
}
.markdown-body h1, .markdown-body h2, .markdown-body h3, .markdown-body h4, .markdown-body h5, .markdown-body h6 {
    cursor: text;
    font-weight: bold;
    margin: 20px 0 10px;
    padding: 0;
    position: relative;
}
.markdown-body h1 .mini-icon-link, .markdown-body h2 .mini-icon-link, .markdown-body h3 .mini-icon-link, .markdown-body h4 .mini-icon-link, .markdown-body h5 .mini-icon-link, .markdown-body h6 .mini-icon-link {
    color: #000000;
    display: none;
}
.markdown-body h1:hover a.anchor, .markdown-body h2:hover a.anchor, .markdown-body h3:hover a.anchor, .markdown-body h4:hover a.anchor, .markdown-body h5:hover a.anchor, .markdown-body h6:hover a.anchor {
    line-height: 1;
    margin-left: -22px;
    padding-left: 0;
    text-decoration: none;
    top: 15%;
}
.markdown-body h1:hover a.anchor .mini-icon-link, .markdown-body h2:hover a.anchor .mini-icon-link, .markdown-body h3:hover a.anchor .mini-icon-link, .markdown-body h4:hover a.anchor .mini-icon-link, .markdown-body h5:hover a.anchor .mini-icon-link, .markdown-body h6:hover a.anchor .mini-icon-link {
    display: inline-block;
}
.markdown-body h1 tt, .markdown-body h1 code, .markdown-body h2 tt, .markdown-body h2 code, .markdown-body h3 tt, .markdown-body h3 code, .markdown-body h4 tt, .markdown-body h4 code, .markdown-body h5 tt, .markdown-body h5 code, .markdown-body h6 tt, .markdown-body h6 code {
    font-size: inherit;
}
.markdown-body h1 {
    color: #000000;
    font-size: 28px;
}
.markdown-body h2 {
    border-bottom: 1px solid #CCCCCC;
    color: #000000;
    font-size: 24px;
}
.markdown-body h3 {
    font-size: 18px;
}
.markdown-body h4 {
    font-size: 16px;
}
.markdown-body h5 {
    font-size: 14px;
}
.markdown-body h6 {
    color: #777777;
    font-size: 14px;
}
.markdown-body p, .markdown-body blockquote, .markdown-body ul, .markdown-body ol, .markdown-body dl, .markdown-body table, .markdown-body pre {
    margin: 15px 0;
}
.markdown-body li ul, .markdown-body li ol {
    margin-top: 0;
}
.markdown-body hr {
    border: 0 none;
    color: #CCCCCC;
    height: 4px;
    padding: 0;
}
.markdown-body > h2:first-child, .markdown-body > h1:first-child, .markdown-body > h1:first-child + h2, .markdown-body > h3:first-child, .markdown-body > h4:first-child, .markdown-body > h5:first-child, .markdown-body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}
.markdown-body a:first-child h1, .markdown-body a:first-child h2, .markdown-body a:first-child h3, .markdown-body a:first-child h4, .markdown-body a:first-child h5, .markdown-body a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}
.markdown-body h1 + p, .markdown-body h2 + p, .markdown-body h3 + p, .markdown-body h4 + p, .markdown-body h5 + p, .markdown-body h6 + p {
    margin-top: 0;
}
.markdown-body li p.first {
    display: inline-block;
}
.markdown-body ul, .markdown-body ol {
    padding-left: 30px;
}
.markdown-body ul.no-list, .markdown-body ol.no-list {
    list-style-type: none;
    padding: 0;
}
.markdown-body ul li > *:first-child, .markdown-body ol li > *:first-child {
    margin-top: 0;
}
.markdown-body ul ul, .markdown-body ul ol, .markdown-body ol ol, .markdown-body ol ul {
    margin-bottom: 0;
}
.markdown-body dl {
    padding: 0;
}
.markdown-body dl dt {
    font-size: 14px;
    font-style: italic;
    font-weight: bold;
    margin: 15px 0 5px;
    padding: 0;
}
.markdown-body dl dt:first-child {
    padding: 0;
}
.markdown-body dl dt > *:first-child {
    margin-top: 0;
}
.markdown-body dl dt > *:last-child {
    margin-bottom: 0;
}
.markdown-body dl dd {
    margin: 0 0 15px;
    padding: 0 15px;
}
.markdown-body dl dd > *:first-child {
    margin-top: 0;
}
.markdown-body dl dd > *:last-child {
    margin-bottom: 0;
}
.markdown-body blockquote {
    border-left: 4px solid #DDDDDD;
    color: #777777;
    padding: 0 15px;
}
.markdown-body blockquote > *:first-child {
    margin-top: 0;
}
.markdown-body blockquote > *:last-child {
    margin-bottom: 0;
}
.markdown-body table th {
    font-weight: bold;
}
.markdown-body table th, .markdown-body table td {
    border: 1px solid #CCCCCC;
    padding: 6px 13px;
}
.markdown-body table tr {
    background-color: #FFFFFF;
    border-top: 1px solid #CCCCCC;
}
.markdown-body table tr:nth-child(2n) {
    background-color: #F8F8F8;
}
.markdown-body img {
    max-width: 100%;
}
.markdown-body span.frame {
    display: block;
    overflow: hidden;
}
.markdown-body span.frame > span {
    border: 1px solid #DDDDDD;
    display: block;
    float: left;
    margin: 13px 0 0;
    overflow: hidden;
    padding: 7px;
    width: auto;
}
.markdown-body span.frame span img {
    display: block;
    float: left;
}
.markdown-body span.frame span span {
    clear: both;
    color: #333333;
    display: block;
    padding: 5px 0 0;
}
.markdown-body span.align-center {
    clear: both;
    display: block;
    overflow: hidden;
}
.markdown-body span.align-center > span {
    display: block;
    margin: 13px auto 0;
    overflow: hidden;
    text-align: center;
}
.markdown-body span.align-center span img {
    margin: 0 auto;
    text-align: center;
}
.markdown-body span.align-right {
    clear: both;
    display: block;
    overflow: hidden;
}
.markdown-body span.align-right > span {
    display: block;
    margin: 13px 0 0;
    overflow: hidden;
    text-align: right;
}
.markdown-body span.align-right span img {
    margin: 0;
    text-align: right;
}
.markdown-body span.float-left {
    display: block;
    float: left;
    margin-right: 13px;
    overflow: hidden;
}
.markdown-body span.float-left span {
    margin: 13px 0 0;
}
.markdown-body span.float-right {
    display: block;
    float: right;
    margin-left: 13px;
    overflow: hidden;
}
.markdown-body span.float-right > span {
    display: block;
    margin: 13px auto 0;
    overflow: hidden;
    text-align: right;
}
.markdown-body code, .markdown-body tt {
		font-family: Consolas, "Liberation Mono", Courier, monospace;
    background-color: #F8F8F8;
    border: 1px solid #EAEAEA;
    border-radius: 3px 3px 3px 3px;
    margin: 0 2px;
    padding: 0 5px;
    white-space: nowrap;
}
.markdown-body pre > code {
		font-size: 14px;
    background: none repeat scroll 0 0 transparent;
    border: medium none;
    margin: 0;
    padding: 0;
    white-space: pre;
}
.markdown-body .highlight pre, .markdown-body pre {
    background-color: #F8F8F8;
    border: 1px solid #CCCCCC;
    border-radius: 3px 3px 3px 3px;
    font-size: 13px;
    line-height: 19px;
    overflow: auto;
    padding: 6px 10px;
}
.markdown-body pre code, .markdown-body pre tt {
    background-color: transparent;
    border: medium none;
}
.container .logo {
    display: block;
    text-align: right;
    font-size: 10px;
}

		</style>
	</head>
	<body>
  <div class="container">
    <div class="nav-wrap">
      <div class="nav"></div>
      
    </div>
  	<div class="markdown-body"><h1>2.2 strconv — 字符串和基本数据类型之间转换</h1>

<p>这里的基本数据类型包括：布尔、整型（包括有/无符号、二进制、八进制、十进制和十六进制）和浮点型等。</p>

<h2>2.2.1 strconv 包转换错误处理</h2>

<p>介绍具体的转换之前，先看看 <em>strconv</em> 中的错误处理。</p>

<p>由于将字符串转为其他数据类型可能会出错，<em>strconv</em> 包定义了两个 <em>error</em> 类型的变量：<em>ErrRange</em> 和 <em>ErrSyntax</em>。其中，<em>ErrRange</em> 表示值超过了类型能表示的最大范围，比如将 &#34;128&#34; 转为 int8 就会返回这个错误；<em>ErrSyntax</em> 表示语法错误，比如将 &#34;&#34; 转为 int 类型会返回这个错误。</p>

<p>然而，在返回错误的时候，不是直接将上面的变量值返回，而是通过构造一个 <em>NumError</em> 类型的 <em>error</em> 对象返回。<em>NumError</em> 结构的定义如下：</p>

<pre><code>// A NumError records a failed conversion.
type NumError struct {
    Func string // the failing function (ParseBool, ParseInt, ParseUint, ParseFloat)
    Num  string // the input
    Err  error  // the reason the conversion failed (ErrRange, ErrSyntax)
}
</code></pre>

<p>可见，该结构记录了转换过程中发生的错误信息。该结构不仅包含了一个 <em>error</em> 类型的成员，记录具体的错误信息，而且它自己也实现了 <em>error</em> 接口：</p>

<pre><code>func (e *NumError) Error() string {
    return &#34;strconv.&#34; + e.Func + &#34;: &#34; + &#34;parsing &#34; + Quote(e.Num) + &#34;: &#34; + e.Err.Error()
}
</code></pre>

<p>包的实现中，定义了两个便捷函数，用于构造 <em>NumError</em> 对象：</p>

<pre><code>func syntaxError(fn, str string) *NumError {
    return &amp;NumError{fn, str, ErrSyntax}
}

func rangeError(fn, str string) *NumError {
    return &amp;NumError{fn, str, ErrRange}
}
</code></pre>

<p>在遇到 <em>ErrSyntax</em> 或 <em>ErrRange</em> 错误时，通过上面的函数构造 <em>NumError</em> 对象。</p>

<h2>2.2.2 字符串和整型之间的转换</h2>

<h3>2.2.2.1 字符串转为整型</h3>

<p>包括三个函数：ParseInt、ParseUint 和 Atoi，函数原型如下：</p>

<pre><code>func ParseInt(s string, base int, bitSize int) (i int64, err error)
func ParseUint(s string, base int, bitSize int) (n uint64, err error)
func Atoi(s string) (i int, err error)
</code></pre>

<p>其中，Atoi 是 ParseInt 的便捷版，内部通过调用 <em>ParseInt(s, 10, 0)</em> 来实现的；ParseInt 转为有符号整型；ParseUint 转为无符号整型，着重介绍 ParseInt。</p>

<p>参数 <em>base</em> 代表字符串按照给定的进制进行解释。一般的，base 的取值为 2~36，如果 base 的值为 0，则会根据字符串的前缀来确定 base 的值：&#34;0x&#34; 表示 16 进制； &#34;0&#34; 表示 8 进制；否则就是 10 进制。</p>

<p>参数 <em>bitSize</em> 表示的是整数取值范围，或者说整数的具体类型。取值 0、8、16、32 和 64 分别代表 int、int8、int16、int32 和 int64。</p>

<p>这里有必要说一下，当 bitSize==0 时的情况。</p>

<p>Go中，int/uint 类型，不同系统能表示的范围是不一样的，目前的实现是，32 位系统占 4 个字节；64 位系统占 8 个字节。当 bitSize==0 时，应该表示 32 位还是 64 位呢？这里没有利用 <em>runtime.GOARCH</em> 之类的方式，而是巧妙的通过如下表达式确定 intSize：</p>

<pre><code>const intSize = 32 &lt;&lt; uint(^uint(0)&gt;&gt;63)
const IntSize = intSize // number of bits in int, uint (32 or 64)
</code></pre>

<p>主要是 <em>^uint(0)&gt;&gt;63</em> 这个表达式。操作符 <em>^</em> 在这里是一元操作符 按位取反，而不是 按位异或。更多解释可以参考：<a href="http://studygolang.com/topics/303">Go位运算：取反和异或</a>。</p>

<p>问题：下面的代码 n 和 err 的值分别是什么？</p>

<pre><code>n, err := strconv.ParseInt(&#34;128&#34;, 10, 8)
</code></pre>

<p>在 <em>ParseInt/ParseUint</em> 的实现中，如果字符串表示的整数超过了 bitSize 参数能够表示的范围，则会返回 ErrRange，同时会返回 bitSize 能够表示的最大或最小值。因此，这里的 n 是 127。</p>

<p>另外，<em>ParseInt</em> 返回的是 int64，这是为了能够容纳所有的整型，在实际使用中，可以根据传递的 bitSize，然后将结果转为实际需要的类型。</p>

<p>转换的基本原理（以 &#34;128&#34; 转 为 10 进制 int 为例）：</p>

<pre><code>s := &#34;128&#34;
n := 0
for i := 0; i &lt; len(s); i++ {
    n *= 10 + s[i]  // base
}
</code></pre>

<p>在循环处理的过程中，会检查数据的有效性和是否越界等。</p>

<h3>2.2.2.2 整型转为字符串</h3>

<p>实际应用中，我们经常会遇到需要将字符串和整型连接起来，在Java中，可以通过操作符 &#34;+&#34; 做到。不过，在Go语言中，你需要将整型转为字符串类型，然后才能进行连接。这个时候，<em>strconv</em> 包中的整型转字符串的相关函数就派上用场了。这些函数签名如下：</p>

<pre><code>func FormatUint(i uint64, base int) string  // 无符号整型转字符串
func FormatInt(i int64, base int) string    // 有符号整型转字符串
func Itoa(i int) string
</code></pre>

<p>其中，<em>Itoa</em> 内部直接调用 <em>FormatInt(i, 10)</em> 实现的。base 参数可以取 2~36（0-9，a-z）。</p>

<p>转换的基本原理（以 10 进制的 127 转 string 为例） ：</p>

<pre><code>const digits = &#34;0123456789abcdefghijklmnopqrstuvwxyz&#34;
u := uint64(127)
var a [65]byte
i := len(a)
b := uint64(base)
for u &gt;= b {
    i--
    a[i] = digits[uintptr(u%b)]
    u /= b
}
i--
a[i] = digits[uintptr(u)]
return string(a[1:])
</code></pre>

<p>即将整数每一位数字对应到相应的字符，存入字符数组中，最后字符数组转为字符串即为结果。</p>

<p>具体实现时，当 base 是 2 的幂次方时，有优化处理（移位和掩码）；十进制也做了优化。</p>

<p>标准库还提供了另外两个函数：<em>AppendInt</em> 和 <em>AppendUint</em>，这两个函数不是将整数转为字符串，而是将整数转为字符数组 append 到目标字符数组中。（最终，我们也可以通过返回的 []byte 得到字符串）</p>

<p>除了使用上述方法将整数转为字符串外，经常见到有人使用 <em>fmt</em> 包来做这件事。如：</p>

<pre><code>fmt.Sprintf(&#34;%d&#34;, 127)
</code></pre>

<p>那么，这两种方式我们该怎么选择呢？我们主要来考察一下性能。</p>

<pre><code>startTime := time.Now()
for i := 0; i &lt; 10000; i++ {
    fmt.Sprintf(&#34;%d&#34;, i)
}   
fmt.Println(time.Now().Sub(startTime))

startTime := time.Now()
for i := 0; i &lt; 10000; i++ {
    strconv.Itoa(i)
}   
fmt.Println(time.Now().Sub(startTime))
</code></pre>

<p>我们分别循环转换了10000次。<em>Sprintf</em> 的时间是 3.549761ms，而 <em>Itoa</em> 的时间是 848.208us，相差 4 倍多。</p>

<p><em>Sprintf</em> 性能差些可以预见，因为它接收的是 interface，需要进行反射等操作。个人建议使用 <em>strconv</em> 包中的方法进行转换。</p>

<p>注意：别想着通过 string(65) 这种方式将整数转为字符串，这样实际上得到的会是 ASCCII 值为 65 的字符，即 &#39;A&#39;。</p>

<p>思考：</p>

<pre><code>给定一个 40 以内的正整数，如何快速判断其是否是 2 的幂次方？
</code></pre>

<p><em>提示：在 strconv 包源码 itoa.go 文件中找答案</em></p>

<h2>2.2.3 字符串和布尔值之间的转换</h2>

<p>Go中字符串和布尔值之间的转换比较简单，主要有三个函数：</p>

<pre><code>// 接受 1, t, T, TRUE, true, True, 0, f, F, FALSE, false, False 等字符串；
// 其他形式的字符串会返回错误
func ParseBool(str string) (value bool, err error)
// 直接返回 &#34;true&#34; 或 &#34;false&#34;
func FormatBool(b bool) string
// 将 &#34;true&#34; 或 &#34;false&#34; append 到 dst 中
// 这里用了一个 append 函数对于字符串的特殊形式：append(dst, &#34;true&#34;...)
func AppendBool(dst []byte, b bool)
</code></pre>

<h2>2.2.4 字符串和浮点数之间的转换</h2>

<p>类似的，包含三个函数：</p>

<pre><code>func ParseFloat(s string, bitSize int) (f float64, err error)
func FormatFloat(f float64, fmt byte, prec, bitSize int) string
func AppendFloat(dst []byte, f float64, fmt byte, prec int, bitSize int)
</code></pre>

<p>函数的命名和作用跟上面讲解的其他类型一致。</p>

<p>关于 <em>FormatFloat</em> 的 <em>fmt</em> 参数， 在第一章第三节<a href="/chapter01/01.3.html">格式化IO</a>中有详细介绍。而 <em>prec</em> 表示有效数字（对 <em>fmt=&#39;b&#39;</em> 无效），对于 &#39;e&#39;, &#39;E&#39; 和 &#39;f&#39;，有效数字用于小数点之后的位数；对于 &#39;g&#39; 和 &#39;G&#39;，则是所有的有效数字。例如：</p>

<pre><code>strconv.FormatFloat(1223.13252, &#39;e&#39;, 3, 32) // 结果：1.22e+03
strconv.FormatFloat(1223.13252, &#39;g&#39;, 3, 32) // 结果：1.223e+03
</code></pre>

<p>由于浮点数有精度的问题，精度不一样，ParseFloat 和 FormatFloat 可能达不到互逆的效果。如：</p>

<pre><code>s := strconv.FormatFloat(1234.5678, &#39;g&#39;, 6, 64)
strconv.ParseFloat(s, 64)
</code></pre>

<p>另外，fmt=&#39;b&#39; 时，得到的字符串是无法通过 <em>ParseFloat</em> 还原的。</p>

<p>特别地（不区分大小写），+inf/inf，+infinity/infinity，-inf/-infinity 和 nan 通过 ParseFloat 转换分别返回对应的值（在 math 包中定义）。</p>

<p>同样的，基于性能的考虑，应该使用 <em>FormatFloat</em> 而不是 <em>fmt.Sprintf</em>。</p>

<h2>2.2.5 其他导出的函数</h2>

<p>如果要输出这样一句话：<em>This is &#34;studygolang.com&#34; website</em>. 该如何做？</p>

<p>So easy:</p>

<pre><code>fmt.Println(`This is &#34;studygolang.com&#34; website`)
</code></pre>

<p>如果没有 <em>``</em> 符号，该怎么做？转义：</p>

<pre><code>fmt.Println(&#34;This is \&#34;studygolang.com\&#34; website&#34;)
</code></pre>

<p>除了这两种方法，<em>strconv</em> 包还提供了函数这做件事（Quote 函数）。我们称 &#34;studygolang.com&#34; 这种用双引号引起来的字符串为 Go 语言字面值字符串（Go string literal）。</p>

<p>上面的一句话可以这么做：</p>

<pre><code>fmt.Println(&#34;This is&#34;, strconv.Quote(&#34;studygolang.com&#34;), &#34;website&#34;)
</code></pre>

<h1>导航</h1>

<ul>
<li>上一节：<a href="/chapter02/02.1.html">strings — 字符串操作</a></li>
<li>下一节：<a href="02.3.html">regexp — 正则表达式</a></li>
</ul>
<div class="logo">Generated by <a href="https://github.com/fairlyblank/md2min">md2min</a></div></div>
  <div>
	</body>
</html>
