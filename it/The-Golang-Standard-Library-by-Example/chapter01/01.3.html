<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="chrome=1">
		<title></title>
		<style text="text/css">
body {
    overflow-x: hidden;
}
.container {
		margin: 0 auto;
		width: 1020px;
}
.nav-wrap {
    display: block;
    height: 650px;
    float: left;
    position: fixed;
		padding: 3px;
		margin: 0;
		border: 0;
		font: 13px Helvetica, arial, freesans, clean, sans-serif;
		line-height: 1.4;
    
}
.nav {
		display: block;
		float: left;
		position: fixed;
		padding: 3px;
		border-radius: 2px;
		margin: 40px 0 0 0;
		border: 0;
		font: 13px Helvetica, arial, freesans, clean, sans-serif;
		line-height: 1.4;
    background: #ffffff; overflow: hidden;
}
.nav ul {
		background: #fafafb;
		border-radius: 2px;
		border: 1px solid #d8d8d8;
		margin: 0;
		padding: 0;
		list-style: none;
		display: block;
}
.nav ul li {
		display: list-item;
		border-top: 1px solid #fff;
		border-bottom: 1px solid #eee;
}
.nav ul li a {
		display: block;
		padding: 8px 10px 8px 8px;
		text-shadow: 0 1px 0 #fff;
		border-left: 2px solid #fafafb;
		color: #4183c4;
		text-decoration: none;
}
.nav ul li a:-webkit-any-link {
		cursor: auto;
}
.markdown-body {
		font: 13px Helvetica, arial, freesans, clean, sans-serif;
		display: block;
		width: 800px;
    margin: 0 auto;
    font-size: 14px;
    line-height: 1.6;
}
.markdown-body > *:first-child {
    margin-top: 0 !important;
}
.markdown-body > *:last-child {
    margin-bottom: 0 !important;
}
.markdown-body a {
    text-decoration: none;
}
.markdown-body a:hover {
    text-decoration: underline;
}
.markdown-body a.absent {
    color: #CC0000;
}
.markdown-body a.anchor {
    bottom: 0;
    cursor: pointer;
    display: block;
    left: 0;
    margin-left: -30px;
    padding-left: 30px;
    position: absolute;
    top: 0;
}
.markdown-body h1, .markdown-body h2, .markdown-body h3, .markdown-body h4, .markdown-body h5, .markdown-body h6 {
    cursor: text;
    font-weight: bold;
    margin: 20px 0 10px;
    padding: 0;
    position: relative;
}
.markdown-body h1 .mini-icon-link, .markdown-body h2 .mini-icon-link, .markdown-body h3 .mini-icon-link, .markdown-body h4 .mini-icon-link, .markdown-body h5 .mini-icon-link, .markdown-body h6 .mini-icon-link {
    color: #000000;
    display: none;
}
.markdown-body h1:hover a.anchor, .markdown-body h2:hover a.anchor, .markdown-body h3:hover a.anchor, .markdown-body h4:hover a.anchor, .markdown-body h5:hover a.anchor, .markdown-body h6:hover a.anchor {
    line-height: 1;
    margin-left: -22px;
    padding-left: 0;
    text-decoration: none;
    top: 15%;
}
.markdown-body h1:hover a.anchor .mini-icon-link, .markdown-body h2:hover a.anchor .mini-icon-link, .markdown-body h3:hover a.anchor .mini-icon-link, .markdown-body h4:hover a.anchor .mini-icon-link, .markdown-body h5:hover a.anchor .mini-icon-link, .markdown-body h6:hover a.anchor .mini-icon-link {
    display: inline-block;
}
.markdown-body h1 tt, .markdown-body h1 code, .markdown-body h2 tt, .markdown-body h2 code, .markdown-body h3 tt, .markdown-body h3 code, .markdown-body h4 tt, .markdown-body h4 code, .markdown-body h5 tt, .markdown-body h5 code, .markdown-body h6 tt, .markdown-body h6 code {
    font-size: inherit;
}
.markdown-body h1 {
    color: #000000;
    font-size: 28px;
}
.markdown-body h2 {
    border-bottom: 1px solid #CCCCCC;
    color: #000000;
    font-size: 24px;
}
.markdown-body h3 {
    font-size: 18px;
}
.markdown-body h4 {
    font-size: 16px;
}
.markdown-body h5 {
    font-size: 14px;
}
.markdown-body h6 {
    color: #777777;
    font-size: 14px;
}
.markdown-body p, .markdown-body blockquote, .markdown-body ul, .markdown-body ol, .markdown-body dl, .markdown-body table, .markdown-body pre {
    margin: 15px 0;
}
.markdown-body li ul, .markdown-body li ol {
    margin-top: 0;
}
.markdown-body hr {
    border: 0 none;
    color: #CCCCCC;
    height: 4px;
    padding: 0;
}
.markdown-body > h2:first-child, .markdown-body > h1:first-child, .markdown-body > h1:first-child + h2, .markdown-body > h3:first-child, .markdown-body > h4:first-child, .markdown-body > h5:first-child, .markdown-body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}
.markdown-body a:first-child h1, .markdown-body a:first-child h2, .markdown-body a:first-child h3, .markdown-body a:first-child h4, .markdown-body a:first-child h5, .markdown-body a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}
.markdown-body h1 + p, .markdown-body h2 + p, .markdown-body h3 + p, .markdown-body h4 + p, .markdown-body h5 + p, .markdown-body h6 + p {
    margin-top: 0;
}
.markdown-body li p.first {
    display: inline-block;
}
.markdown-body ul, .markdown-body ol {
    padding-left: 30px;
}
.markdown-body ul.no-list, .markdown-body ol.no-list {
    list-style-type: none;
    padding: 0;
}
.markdown-body ul li > *:first-child, .markdown-body ol li > *:first-child {
    margin-top: 0;
}
.markdown-body ul ul, .markdown-body ul ol, .markdown-body ol ol, .markdown-body ol ul {
    margin-bottom: 0;
}
.markdown-body dl {
    padding: 0;
}
.markdown-body dl dt {
    font-size: 14px;
    font-style: italic;
    font-weight: bold;
    margin: 15px 0 5px;
    padding: 0;
}
.markdown-body dl dt:first-child {
    padding: 0;
}
.markdown-body dl dt > *:first-child {
    margin-top: 0;
}
.markdown-body dl dt > *:last-child {
    margin-bottom: 0;
}
.markdown-body dl dd {
    margin: 0 0 15px;
    padding: 0 15px;
}
.markdown-body dl dd > *:first-child {
    margin-top: 0;
}
.markdown-body dl dd > *:last-child {
    margin-bottom: 0;
}
.markdown-body blockquote {
    border-left: 4px solid #DDDDDD;
    color: #777777;
    padding: 0 15px;
}
.markdown-body blockquote > *:first-child {
    margin-top: 0;
}
.markdown-body blockquote > *:last-child {
    margin-bottom: 0;
}
.markdown-body table th {
    font-weight: bold;
}
.markdown-body table th, .markdown-body table td {
    border: 1px solid #CCCCCC;
    padding: 6px 13px;
}
.markdown-body table tr {
    background-color: #FFFFFF;
    border-top: 1px solid #CCCCCC;
}
.markdown-body table tr:nth-child(2n) {
    background-color: #F8F8F8;
}
.markdown-body img {
    max-width: 100%;
}
.markdown-body span.frame {
    display: block;
    overflow: hidden;
}
.markdown-body span.frame > span {
    border: 1px solid #DDDDDD;
    display: block;
    float: left;
    margin: 13px 0 0;
    overflow: hidden;
    padding: 7px;
    width: auto;
}
.markdown-body span.frame span img {
    display: block;
    float: left;
}
.markdown-body span.frame span span {
    clear: both;
    color: #333333;
    display: block;
    padding: 5px 0 0;
}
.markdown-body span.align-center {
    clear: both;
    display: block;
    overflow: hidden;
}
.markdown-body span.align-center > span {
    display: block;
    margin: 13px auto 0;
    overflow: hidden;
    text-align: center;
}
.markdown-body span.align-center span img {
    margin: 0 auto;
    text-align: center;
}
.markdown-body span.align-right {
    clear: both;
    display: block;
    overflow: hidden;
}
.markdown-body span.align-right > span {
    display: block;
    margin: 13px 0 0;
    overflow: hidden;
    text-align: right;
}
.markdown-body span.align-right span img {
    margin: 0;
    text-align: right;
}
.markdown-body span.float-left {
    display: block;
    float: left;
    margin-right: 13px;
    overflow: hidden;
}
.markdown-body span.float-left span {
    margin: 13px 0 0;
}
.markdown-body span.float-right {
    display: block;
    float: right;
    margin-left: 13px;
    overflow: hidden;
}
.markdown-body span.float-right > span {
    display: block;
    margin: 13px auto 0;
    overflow: hidden;
    text-align: right;
}
.markdown-body code, .markdown-body tt {
		font-family: Consolas, "Liberation Mono", Courier, monospace;
    background-color: #F8F8F8;
    border: 1px solid #EAEAEA;
    border-radius: 3px 3px 3px 3px;
    margin: 0 2px;
    padding: 0 5px;
    white-space: nowrap;
}
.markdown-body pre > code {
		font-size: 14px;
    background: none repeat scroll 0 0 transparent;
    border: medium none;
    margin: 0;
    padding: 0;
    white-space: pre;
}
.markdown-body .highlight pre, .markdown-body pre {
    background-color: #F8F8F8;
    border: 1px solid #CCCCCC;
    border-radius: 3px 3px 3px 3px;
    font-size: 13px;
    line-height: 19px;
    overflow: auto;
    padding: 6px 10px;
}
.markdown-body pre code, .markdown-body pre tt {
    background-color: transparent;
    border: medium none;
}
.container .logo {
    display: block;
    text-align: right;
    font-size: 10px;
}

		</style>
	</head>
	<body>
  <div class="container">
    <div class="nav-wrap">
      <div class="nav"></div>
      
    </div>
  	<div class="markdown-body"><h1>1.3 fmt — 格式化IO</h1>

<p>fmt 包实现了格式化I/O函数，类似于C的 printf 和 scanf. 格式“占位符”衍生自C，但比C更简单。</p>

<p>fmt 包的官方文档对Printing和Scanning有很详细的说明。这里就直接引用文档进行说明，同时附上额外的说明或例子，之后再介绍具体的函数使用。</p>

<p>以下例子中用到的类型或变量定义：</p>

<pre><code>type Website struct {
    Name string
}

// 打印结构体时
var site = Website{Name:&#34;studygolang&#34;}
</code></pre>

<h2>Printing</h2>

<h3>占位符</h3>

<p><strong>普通占位符</strong></p>

<pre><code>占位符                     说明                      举例                                      输出
%v      相应值的默认格式。                               Printf(&#34;%v&#34;, site)，Printf(&#34;%+v&#34;, site)  {studygolang}，{Name:studygolang}
        在打印结构体时，“加号”标记（%+v）会添加字段名
%#v     相应值的Go语法表示                          Printf(&#34;#v&#34;, site)                      main.Website{Name:&#34;studygolang&#34;}
%T      相应值的类型的Go语法表示                       Printf(&#34;%T&#34;, site)                      main.Website
%%      字面上的百分号，并非值的占位符                 Printf(&#34;%%&#34;)                            %
</code></pre>

<p><strong>布尔占位符</strong></p>

<pre><code>占位符                     说明                      举例                                      输出
%t      单词 true 或 false。                            Printf(&#34;%t&#34;, true)                      true
</code></pre>

<p><strong>整数占位符</strong></p>

<pre><code>占位符                     说明                      举例                                  输出
%b      二进制表示                                   Printf(&#34;%b&#34;, 5)                     101
%c      相应Unicode码点所表示的字符                   Printf(&#34;%c&#34;, 0x4E2D)                中
%d      十进制表示                                   Printf(&#34;%d&#34;, 0x12)                  18
%o      八进制表示                                   Printf(&#34;%d&#34;, 10)                    12
%q      单引号围绕的字符字面值，由Go语法安全地转义      Printf(&#34;%q&#34;, 0x4E2D)                &#39;中&#39;
%x      十六进制表示，字母形式为小写 a-f              Printf(&#34;%x&#34;, 13)                    d
%X      十六进制表示，字母形式为大写 A-F              Printf(&#34;%x&#34;, 13)                    D
%U      Unicode格式：U+1234，等同于 &#34;U+%04X&#34;           Printf(&#34;%U&#34;, 0x4E2D)                U+4E2D
</code></pre>

<p><strong>浮点数和复数的组成部分（实部和虚部）</strong></p>

<pre><code>占位符                     说明                                              举例                                  输出
%b      无小数部分的，指数为二的幂的科学计数法，与 strconv.FormatFloat   
        的 &#39;b&#39; 转换格式一致。例如 -123456p-78
%e      科学计数法，例如 -1234.456e+78                                  Printf(&#34;%e&#34;, 10.2)                          1.020000e+01
%E      科学计数法，例如 -1234.456E+78                                  Printf(&#34;%e&#34;, 10.2)                          1.020000E+01
%f      有小数点而无指数，例如 123.456                                 Printf(&#34;%f&#34;, 10.2)                          10.200000
%g      根据情况选择 %e 或 %f 以产生更紧凑的（无末尾的0）输出             Printf(&#34;%g&#34;, 10.20)                         10.2
%G      根据情况选择 %E 或 %f 以产生更紧凑的（无末尾的0）输出             Printf(&#34;%G&#34;, 10.20+2i)                      (10.2+2i)
</code></pre>

<p><strong>字符串与字节切片</strong></p>

<pre><code>占位符                     说明                                              举例                                  输出
%s      输出字符串表示（string类型或[]byte)                            Printf(&#34;%s&#34;, []byte(&#34;Go语言学习园地&#34;))        Go语言学习园地
%q      双引号围绕的字符串，由Go语法安全地转义                            Printf(&#34;%q&#34;, &#34;Go语言学习园地&#34;)                &#34;Go语言学习园地&#34;
%x      十六进制，小写字母，每字节两个字符                               Printf(&#34;%x&#34;, &#34;golang&#34;)                      676f6c616e67
%X      十六进制，大写字母，每字节两个字符                               Printf(&#34;%X&#34;, &#34;golang&#34;)                      676F6C616E67
</code></pre>

<p><strong>指针</strong></p>

<pre><code>占位符                     说明                                              举例                                  输出
%p      十六进制表示，前缀 0x                                            Printf(&#34;%p&#34;, &amp;site)                         0x4f57f0
</code></pre>

<p>这里没有 &#39;u&#39; 标记。若整数为无符号类型，他们就会被打印成无符号的。类似地，这里也不需要指定操作数的大小（int8，int64）。</p>

<p>宽度与精度的控制格式以Unicode码点为单位。（这点与C的 printf 不同，它以字节数为单位）二者或其中之一均可用字符 &#39;*&#39; 表示，此时它们的值会从下一个操作数中获取，该操作数的类型必须为 int。</p>

<p>对数值而言，宽度为该数值占用区域的最小宽度；精度为小数点之后的位数。 但对于 %g/%G 而言，精度为所有数字的总数。例如，对于123.45，格式 %6.2f 会打印123.45，而 %.4g 会打印123.5。%e 和 %f 的默认精度为6；但对于 %g 而言，它的默认精度为确定该值所必须的最小位数。</p>

<p>对大多数的值而言，宽度为输出的最小字符数，如果必要的话会为已格式化的形式填充空格。对字符串而言，精度为输出的最大字符数，如果必要的话会直接截断。</p>

<p><strong>其它标记</strong></p>

<pre><code>占位符                     说明                                              举例                                  输出
+       总打印数值的正负号；对于%q（%+q）保证只输出ASCII编码的字符。         Printf(&#34;%+q&#34;, &#34;中文&#34;)                 &#34;\u4e2d\u6587&#34;
-       在右侧而非左侧填充空格（左对齐该区域）
#       备用格式：为八进制添加前导 0（%#o），为十六进制添加前导 0x（%#x）或 Printf(&#34;%#U&#34;, &#39;中&#39;)                      U+4E2D &#39;中&#39;
        0X（%#X），为 %p（%#p）去掉前导 0x；如果可能的话，%q（%#q）会打印原始
        （即反引号围绕的）字符串；如果是可打印字符，%U（%#U）会写出该字符的
        Unicode 编码形式（如字符 x 会被打印成 U+0078 &#39;x&#39;）。
&#39; &#39;     （空格）为数值中省略的正负号留出空白（% d）；
        以十六进制（% x, % X）打印字符串或切片时，在字节之间用空格隔开
0       填充前导的0而非空格；对于数字，这会将填充移到正负号之后
</code></pre>

<p>标记有时会被占位符忽略，所以不要指望它们。例如十进制没有备用格式，因此 %#d 与 %d 的行为相同。</p>

<p>对于每一个 Printf 类的函数，都有一个 Print 函数，该函数不接受任何格式化，它等价于对每一个操作数都应用 %v。另一个变参函数 Println 会在操作数之间插入空白，并在末尾追加一个换行符。</p>

<p>不考虑占位符的话，如果操作数是接口值，就会使用其内部的具体值，而非接口本身。 因此：</p>

<pre><code>var i interface{} = 23
fmt.Printf(&#34;%v\n&#34;, i)
</code></pre>

<p>会打印 23。</p>

<p>若一个操作数实现了 Formatter 接口，该接口就能更好地用于控制格式化。</p>

<p>若其格式（它对于 Println 等函数是隐式的 %v）对于字符串是有效的 （%s %q %v %x %X），以下两条规则也适用：</p>

<pre><code>1. 若一个操作数实现了 error 接口，Error 方法就能将该对象转换为字符串，随后会根据占位符的需要进行格式化。
2. 若一个操作数实现了 String() string 方法，该方法能将该对象转换为字符串，随后会根据占位符的需要进行格式化。
</code></pre>

<p>为避免以下这类递归的情况：</p>

<pre><code>type X string
func (x X) String() string { return Sprintf(&#34;&lt;%s&gt;&#34;, x) }
</code></pre>

<p>需要在递归前转换该值：</p>

<pre><code>func (x X) String() string { return Sprintf(&#34;&lt;%s&gt;&#34;, string(x)) }
</code></pre>

<p><strong>格式化错误</strong></p>

<p>如果给占位符提供了无效的实参（例如将一个字符串提供给 %d），所生成的字符串会包含该问题的描述，如下例所示：</p>

<pre><code>类型错误或占位符未知：%!verb(type=value)
    Printf(&#34;%d&#34;, hi):          %!d(string=hi)
实参太多：%!(EXTRA type=value)
    Printf(&#34;hi&#34;, &#34;guys&#34;):      hi%!(EXTRA string=guys)
实参太少： %!verb(MISSING)
    Printf(&#34;hi%d&#34;):            hi %!d(MISSING)
宽度或精度不是int类型: %!(BADWIDTH) 或 %!(BADPREC)
    Printf(&#34;%*s&#34;, 4.5, &#34;hi&#34;):  %!(BADWIDTH)hi
    Printf(&#34;%.*s&#34;, 4.5, &#34;hi&#34;): %!(BADPREC)hi
所有错误都始于“%!”，有时紧跟着单个字符（占位符），并以小括号括住的描述结尾。
</code></pre>

<h2>Scanning</h2>

<p>一组类似的函数通过扫描已格式化的文本来产生值。Scan、Scanf 和 Scanln 从 os.Stdin 中读取；Fscan、Fscanf 和 Fscanln 从指定的 io.Reader 中读取； Sscan、Sscanf 和 Sscanln 从实参字符串中读取。Scanln、Fscanln 和 Sscanln 在换行符处停止扫描，且需要条目紧随换行符之后；Scanf、Fscanf 和 Sscanf 需要输入换行符来匹配格式中的换行符；其它函数则将换行符视为空格。</p>

<p>Scanf、Fscanf 和 Sscanf 根据格式字符串解析实参，类似于 Printf。例如，%x 会将一个整数扫描为十六进制数，而 %v 则会扫描该值的默认表现格式。</p>

<p>格式化行为类似于 Printf，但也有如下例外：</p>

<pre><code>%p 没有实现
%T 没有实现
%e %E %f %F %g %G 都完全等价，且可扫描任何浮点数或复数数值
%s 和 %v 在扫描字符串时会将其中的空格作为分隔符
标记 # 和 + 没有实现
</code></pre>

<p>在使用 %v 占位符扫描整数时，可接受友好的进制前缀0（八进制）和0x（十六进制）。</p>

<p>宽度被解释为输入的文本（%5s 意为最多从输入中读取5个 rune 来扫描成字符串），而扫描函数则没有精度的语法（没有 %5.2f，只有 %5f）。</p>

<p>当以某种格式进行扫描时，无论在格式中还是在输入中，所有非空的连续空白字符 （除换行符外）都等价于单个空格。由于这种限制，格式字符串文本必须匹配输入的文本，如果不匹配，扫描过程就会停止，并返回已扫描的实参数。</p>

<p>在所有的扫描参数中，若一个操作数实现了 Scan 方法（即它实现了 Scanner 接口）， 该操作数将使用该方法扫描其文本。此外，若已扫描的实参数少于所提供的实参数，就会返回一个错误。</p>

<p>所有需要被扫描的实参都必须是基本类型或 Scanner 接口的实现。</p>

<p>注意：Fscan 等函数会从输入中多读取一个字符（rune），因此，如果循环调用扫描函数，可能会跳过输入中的某些数据。一般只有在输入的数据中没有空白符时该问题才会出现。若提供给 Fscan 的读取器实现了 ReadRune，就会用该方法读取字符。若此读取器还实现了 UnreadRune 方法，就会用该方法保存字符，而连续的调用将不会丢失数据。若要为没有 ReadRune 和 UnreadRune 方法的读取器加上这些功能，需使用 bufio.NewReader。</p>

<h2>Print 序列函数</h2>

<p>这里说的 Print 序列函数包括：Fprint/Fprintf/Fprintln/Sprint/Sprintf/Sprintln/Print/Printf/Println。之所以将放在一起介绍，是因为它们的使用方式类似、参数意思也类似。</p>

<p>一般的，我们将Fprint/Fprintf/Fprintln归为一类；Sprint/Sprintf/Sprintln归为一类；Print/Printf/Println归为另一类。其中，Print/Printf/Println会调用相应的F开头一类函数。如：</p>

<pre><code>func Print(a ...interface{}) (n int, err error) {
    return Fprint(os.Stdout, a...)
}
</code></pre>

<p>Fprint/Fprintf/Fprintln 函数的第一个参数接收一个io.Writer类型，会将内容输出到io.Writer中去。而Print/Printf/Println 函数是将内容输出到标准输出中，因此，直接调用F类函数做这件事，并将os.Stdout作为第一个参数传入。</p>

<p>Sprint/Sprintf/Sprintln 是格式化内容为string类型，而并不输出到某处，需要格式化字符串并返回时，可以用次组函数。</p>

<p>在这三组函数中，<code>S/F/Printf</code>函数通过指定的格式输出或格式化内容；<code>S/F/Print</code>函数只是使用默认的格式输出或格式化内容；<code>S/F/Println</code>函数使用默认的格式输出或格式化内容，同时会在最后加上&#34;换行符&#34;。</p>

<p>Print 序列函数的最后一个参数都是 <code>a ...interface{}</code> 这种不定参数。对于<code>S/F/Printf</code>序列，这个不定参数的实参个数应该和<code>formt</code>参数的占位符个数一致，否则会出现格式化错误；而对于其他函数，当不定参数的实参个数为多个时，它们之间会直接（对于<code>S/F/Print</code>）或通过&#34; &#34;（空格）（对于<code>S/F/Println</code>）连接起来（注：对于<code>S/F/Print</code>，一个非字符串类型前面一个类型也为非字符串类型时，会自动添加一个空格。感谢guoshanhe1983 反馈）。利用这一点，我们可以做如下事情：</p>

<pre><code>result1 := fmt.Sprintln(&#34;studygolang.com&#34;, 2013)
result2 := fmt.Sprint(&#34;studygolang.com&#34;, 2013)
</code></pre>

<p>result1的值是：<code>studygolang.com 2013</code>，result2的值是：<code>studygolang.com2013</code>。这起到了连接字符串的作用，而不需要通过strconv.Itoa()转换。</p>

<p>Print序列函数用的较多，而且也易于使用（可能需要掌握一些常用的占位符用法），接下来我们结合fmt包中几个相关的接口来掌握更多关于Print的内容。</p>

<h2>Stringer 接口</h2>

<p>Stringer接口的定义如下：</p>

<pre><code>type Stringer interface {
    String() string
}
</code></pre>

<p>根据Go语言中实现接口的定义，一个类型只要有 <code>String() string</code> 方法，我们就说它实现了Stringer接口。而在本节开始已经说到，如果格式化输出某种类型的值，只要它实现了String()方法，那么会调用String()方法进行处理。</p>

<p>我们定义如下struct：</p>

<pre><code>type Person struct {
    Name string
    Age  int
    Sex  int
}
</code></pre>

<p>我们给Person实现String方法，这个时候，我们输出Person的实例：</p>

<pre><code>p := &amp;Person{&#34;polaris&#34;, 28, 0}
fmt.Println(p)
</code></pre>

<p>输出：</p>

<pre><code>&amp;{polaris 28 0}
</code></pre>

<p>接下来，为Person增加String方法。</p>

<pre><code>func (this *Person) String() string {
    buffer := bytes.NewBufferString(&#34;This is &#34;)
    buffer.WriteString(this.Name + &#34;, &#34;)
    if this.Sex == 0 {
        buffer.WriteString(&#34;He &#34;)
    } else {
        buffer.WriteString(&#34;She &#34;)
    }
    buffer.WriteString(&#34;is &#34;)
    buffer.WriteString(strconv.Itoa(this.Age))
    buffer.WriteString(&#34; years old.&#34;)
    return buffer.String()
}
</code></pre>

<p>这个时候运行：</p>

<pre><code>p := &amp;Person{&#34;polaris&#34;, 28, 0}
fmt.Println(p)
</code></pre>

<p>输出变为：</p>

<pre><code>This is polaris, He is 28 years old
</code></pre>

<p>可见，Stringer接口和Java中的ToString方法类似。</p>

<h2>Formatter 接口</h2>

<p>Formatter接口的定义如下：</p>

<pre><code>type Formatter interface {
    Format(f State, c rune)
}
</code></pre>

<p>官方文档中关于该接口方法的说明：</p>

<blockquote>
<p>Formatter 接口由带有定制的格式化器的值所实现。 Format 的实现可调用 Sprintf 或 Fprintf(f) 等函数来生成其输出。</p>
</blockquote>

<p>也就是说，通过实现Formatter接口可以做到自定义输出格式（自定义占位符）。</p>

<p>接着上面的例子，我们为Person增加一个方法：</p>

<pre><code>func (this *Person) Format(f fmt.State, c rune) {
    if c == &#39;L&#39; {
        f.Write([]byte(this.String()))
        f.Write([]byte(&#34; Person has three fields.&#34;))
    } else {
        // 没有此句，会导致 fmt.Printf(&#34;%s&#34;, p) 啥也不输出
        f.Write([]byte(fmt.Sprintln(this.String())))
    }
}
</code></pre>

<p>这样，Person便实现了Formatter接口。这时再运行：</p>

<pre><code>p := &amp;Person{&#34;polaris&#34;, 28, 0}
fmt.Printf(&#34;%L&#34;, p)
</code></pre>

<p>输出为：</p>

<pre><code>This is polaris, He is 28 years old. Person has three fields.
</code></pre>

<p>这里需要解释以下几点：</p>

<p>1）fmt.State 是一个接口。由于Format方法是被fmt包调用的，它内部会实例化好一个fmt.State接口的实例，我们不需要关心该接口；</p>

<p>2）可以实现自定义占位符，同时fmt包中和类型相对应的预定义占位符会无效。因此例子中Format的实现加上了else子句；</p>

<p>3）实现了Formatter接口，相应的Stringer接口不起作用。但实现了Formatter接口的类型应该实现Stringer接口，这样方便在Format方法中调用String()方法。就像本例的做法；</p>

<p>4）Format方法的第二个参数是占位符中%后的字母（有精度和宽度会被忽略，只保留字母）；</p>

<p>一般地，我们不需要实现Formatter接口。如果对Formatter接口的实现感兴趣，可以看看标准库math/big包中Int类型的Formatter接口实现。</p>

<p><strong>小贴士</strong></p>

<p>State接口相关说明：</p>

<pre><code>type State interface {
    // Write is the function to call to emit formatted output to be printed.
    // Write 函数用于打印出已格式化的输出。
    Write(b []byte) (ret int, err error)
    // Width returns the value of the width option and whether it has been set.
    // Width 返回宽度选项的值以及它是否已被设置。
    Width() (wid int, ok bool)
    // Precision returns the value of the precision option and whether it has been set.
    // Precision 返回精度选项的值以及它是否已被设置。
    Precision() (prec int, ok bool)

    // Flag returns whether the flag c, a character, has been set.
    // Flag 返回标记 c（一个字符）是否已被设置。
    Flag(c int) bool
}
</code></pre>

<p>fmt包中的print.go文件中的<code>type pp struct</code>实现了State接口。由于State接口有Write方法，因此，实现了State接口的类型必然实现了io.Writer接口。</p>

<h2>GoStringer 接口</h2>

<p>GoStringer 接口定义如下；</p>

<pre><code>type GoStringer interface {
    GoString() string
}
</code></pre>

<p>该接口定义了类型的Go语法格式。用于打印(Printf)格式化占位符为%#v的值。</p>

<p>用前面的例子演示。执行：</p>

<pre><code>p := &amp;Person{&#34;polaris&#34;, 28, 0}
fmt.Printf(&#34;%#v&#34;, p)
</code></pre>

<p>输出：</p>

<pre><code>&amp;main.Person{Name:&#34;polaris&#34;, Age:28, Sex:0}
</code></pre>

<p>接着为Person增加方法：</p>

<pre><code>func (this *Person) GoString() string {
    return &#34;&amp;Person{Name is &#34;+this.Name+&#34;, Age is &#34;+strconv.Itoa(this.Age)+&#34;, Sex is &#34;+strconv.Itoa(this.Sex)+&#34;}&#34;
}
</code></pre>

<p>这个时候再执行</p>

<pre><code>p := &amp;Person{&#34;polaris&#34;, 28, 0}
fmt.Printf(&#34;%#v&#34;, p)
</code></pre>

<p>输出：</p>

<pre><code>&amp;Person{Name is polaris, Age is 28, Sex is 0}
</code></pre>

<p>一般的，我们不需要实现该接口。</p>

<h2>Scan 序列函数</h2>

<p>该序列函数和 Print 序列函数相对应，包括：Fscan/Fscanf/Fscanln/Sscan/Sscanf/Sscanln/Scan/Scanf/Scanln。</p>

<p>一般的，我们将Fscan/Fscanf/Fscanln归为一类；Sscan/Sscanf/Sscanln归为一类；Scan/Scanf/Scanln归为另一类。其中，Scan/Scanf/Scanln会调用相应的F开头一类函数。如：</p>

<pre><code>func Scan(a ...interface{}) (n int, err error) {
    return Fscan(os.Stdin, a...)
}
</code></pre>

<p>Fscan/Fscanf/Fscanln 函数的第一个参数接收一个io.Reader类型，从其读取内容并赋值给响应的实参。而 Scan/Scanf/Scanln 正是从标准输入获取内容，因此，直接调用F类函数做这件事，并将os.Stdin作为第一个参数传入。</p>

<p>Sscan/Sscanf/Sscanln 则直接从字符串中获取内容。</p>

<p>对于Scan/Scanf/Scanln三个函数的区别，我们通过例子来说明，为了方便讲解，我们使用Sscan/Sscanf/Sscanln这组函数。</p>

<p>1) Scan/FScan/Sscan</p>

<pre><code>var (
    name string
    age  int
)
n, _ := fmt.Sscan(&#34;polaris 28&#34;, &amp;name, &amp;age)
// 可以将&#34;polaris 28&#34;中的空格换成&#34;\n&#34;试试
// n, _ := fmt.Sscan(&#34;polaris\n28&#34;, &amp;name, &amp;age)
fmt.Println(n, name, age)
</code></pre>

<p>输出为：</p>

<pre><code>2 polaris 28
</code></pre>

<p>不管&#34;polaris 28&#34;是用空格分隔还是&#34;\n&#34;分隔，输出一样。也就是说，<code>Scan/FScan/Sscan</code> 这组函数将连续由空格分隔的值存储为连续的实参（换行符也记为空格）。</p>

<p>2) Scanf/FScanf/Sscanf</p>

<pre><code>var (
    name string
    age  int
)
n, _ := fmt.Sscanf(&#34;polaris 28&#34;, &#34;%s%d&#34;, &amp;name, &amp;age)
// 可以将&#34;polaris 28&#34;中的空格换成&#34;\n&#34;试试
// n, _ := fmt.Sscanf(&#34;polaris\n28&#34;, &#34;%s%d&#34;, &amp;name, &amp;age)
fmt.Println(n, name, age)
</code></pre>

<p>输出：</p>

<pre><code>2 polaris 28
</code></pre>

<p>如果将&#34;空格&#34;分隔改为&#34;\n&#34;分隔，则输出为：1 polaris 0。可见，<code>Scanf/FScanf/Sscanf</code> 这组函数将连续由空格分隔的值存储为连续的实参， 其格式由 <code>format</code> 决定，换行符处停止扫描(Scan)。</p>

<p>3) Scanln/FScanln/Sscanln</p>

<pre><code>var (
    name string
    age  int
)
n, _ := fmt.Sscanln(&#34;polaris 28&#34;, &amp;name, &amp;age)
// 可以将&#34;polaris 28&#34;中的空格换成&#34;\n&#34;试试
// n, _ := fmt.Sscanln(&#34;polaris\n28&#34;, &amp;name, &amp;age)
fmt.Println(n, name, age)
</code></pre>

<p>输出：</p>

<pre><code>2 polaris 28
</code></pre>

<p><code>Scanln/FScanln/Sscanln</code>表现和上一组一样，遇到&#34;\n&#34;停止（对于Scanln，表示从标准输入获取内容，最后需要回车）。</p>

<p>一般地，我们使用 <code>Scan/Scanf/Scanln</code> 这组函数。</p>

<p><strong>提示</strong></p>

<p>如果你是Windows系统，在使用 <code>Scanf</code> 时，有一个地方需要注意。看下面的代码：</p>

<pre><code>for i := 0; i &lt; 2; i++ {
    var name string
    fmt.Print(&#34;Input Name:&#34;)
    n, err := fmt.Scanf(&#34;%s&#34;, &amp;name)
    fmt.Println(n, err, name)
}
</code></pre>

<p>编译、运行（或直接 go run )，输入：polaris回车。控制台内如下：</p>

<pre><code>Input Name:polaris
1 &lt;nil&gt; polaris
Input Name:0 unexpected newline
</code></pre>

<p>为什么不是让输入两次？第二次好像有默认值一样。</p>

<p>同样的代码在Linux下正常。个人认为这是go在Windows下的一个bug，已经向官方提出：<a href="https://code.google.com/p/go/issues/detail?id=5391">issue5391</a>。</p>

<p>目前的解决方法是：换用Scanln或者改为Scanf(&#34;%s\n&#34;, &amp;name)。</p>

<h2>Scanner 和 ScanState 接口</h2>

<p>基本上，我们不会去自己实现这两个接口，只需要使用上文中相应的Scan函数就可以了。这里只是简单的介绍一下这两个接口的作用。</p>

<p>任何实现了Scan方法的对象都实现了Scanner接口，Scan方法会从输入读取数据并将处理结果存入接收端，接收端必须是有效的指针。Scan方法会被任何Scan、Scanf、Scanln等函数调用，只要对应的参数实现了该方法。Scan方法接收的第一个参数为<code>ScanState</code>接口类型。</p>

<p>ScanState是一个交给用户定制的Scanner接口的参数的接口。Scanner接口可能会进行一次一个字符的扫描或者要求ScanState去探测下一个空白分隔的token。该接口的方法基本上在io包中都有讲解，这里不赘述。</p>

<p>在fmt包中，scan.go文件中的 ss 结构实现了 ScanState 接口。</p>

<h1>导航</h1>

<ul>
<li><a href="/preface.html">目录</a></li>
<li>上一节：<a href="01.2.html">ioutil — 方便的IO操作函数集</a></li>
<li>下一节：<a href="01.4.html">bufio — 缓存IO</a></li>
</ul>
<div class="logo">Generated by <a href="https://github.com/fairlyblank/md2min">md2min</a></div></div>
  <div>
	</body>
</html>
